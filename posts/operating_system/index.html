<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta name="google-adsense-account" content="ca-pub-6504473922193740">
        <title>Operating_system - Ich bin yiwen.</title><meta name="Description" content="An ordinary space for storing and groups pieces of articles."><meta property="og:title" content="Operating_system" />
<meta property="og:description" content="01. Multiprogramming System (一）定義：系統允許多個 jobs (processes) 同時執行，即是
主要目的：提高CPU utilization
作法：透過Job scheduling (or CPU scheduling 工作的排班或者CPU的排班) 技術達成
e.g. 當執行中的process在waiting for I/O completed，則 OS 可以將 CPU 切換給另外一個 process 執行，避免 CPU idle
即只要系統內有夠多的 Jobs 存在，則 CPU idle 機會下降
(二）Multiprogramming Degree
相當於系統內之 processes 數目
一般而言，如果 Degree 越高，則 cpu utilization 越高
Note: Chapter 8 virtual memory Thrashing 例外狀況除外
(三）多個 processes 同時執行之方式有兩個：
Concurrent execution 並行
一顆CPU，大家輪流交錯使用，晚上7-8點給P1，做不下去切給其他的
Parallel execution 平行
多顆CPU或者多核 (core) ，每一個工作都在不同的cpu平行執行
Multiprogramming 跟一顆cpu或者多顆cpu無關，單一 user 也可以 multiprogramming，不限定多個 users。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wysiwyz.github.io/posts/operating_system/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="1993-01-26T14:30:01+08:00" />
<meta property="article:modified_time" content="1993-01-26T14:30:01+08:00" /><meta property="og:site_name" content="Ich bin yiwen." />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Operating_system"/>
<meta name="twitter:description" content="01. Multiprogramming System (一）定義：系統允許多個 jobs (processes) 同時執行，即是
主要目的：提高CPU utilization
作法：透過Job scheduling (or CPU scheduling 工作的排班或者CPU的排班) 技術達成
e.g. 當執行中的process在waiting for I/O completed，則 OS 可以將 CPU 切換給另外一個 process 執行，避免 CPU idle
即只要系統內有夠多的 Jobs 存在，則 CPU idle 機會下降
(二）Multiprogramming Degree
相當於系統內之 processes 數目
一般而言，如果 Degree 越高，則 cpu utilization 越高
Note: Chapter 8 virtual memory Thrashing 例外狀況除外
(三）多個 processes 同時執行之方式有兩個：
Concurrent execution 並行
一顆CPU，大家輪流交錯使用，晚上7-8點給P1，做不下去切給其他的
Parallel execution 平行
多顆CPU或者多核 (core) ，每一個工作都在不同的cpu平行執行
Multiprogramming 跟一顆cpu或者多顆cpu無關，單一 user 也可以 multiprogramming，不限定多個 users。"/>
<meta name="application-name" content="Ich bin yiwen.">
<meta name="apple-mobile-web-app-title" content="Ich bin yiwen."><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/moon_icon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://wysiwyz.github.io/posts/operating_system/" /><link rel="prev" href="http://wysiwyz.github.io/posts/direct-style/" /><link rel="next" href="http://wysiwyz.github.io/posts/algorithm/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Operating_system",
        "inLanguage": "en-us",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/wysiwyz.github.io\/posts\/operating_system\/"
        },"genre": "posts","keywords": "OperatingSystem","wordcount":  2841 ,
        "url": "http:\/\/wysiwyz.github.io\/posts\/operating_system\/","datePublished": "1993-01-26T14:30:01+08:00","dateModified": "1993-01-26T14:30:01+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "celine"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Ich bin yiwen.">Ich bin yiwen.</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Ich bin yiwen.">Ich bin yiwen.</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Operating_system</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>celine</a></span>&nbsp;<span class="post-category">included in <a href="/categories/studynote/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>StudyNote</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="1993-01-26">1993-01-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;2841 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;14 minutes&nbsp;<span id="/posts/operating_system/" class="leancloud_visitors" data-flag-title="Operating_system">
                        <i class="far fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;views
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#io-運作方式">I/O 運作方式</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#ch3-os之development">Ch3. OS之Development</a>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#ch4-process-management-與-thread-management">Ch4: Process Management 與 Thread Management</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="01-multiprogramming-system">01. Multiprogramming System</h1>
<p>(一）定義：系統允許多個 jobs (processes) 同時執行，即是</p>
<p>主要目的：提高CPU utilization</p>
<p>作法：透過Job scheduling (or CPU scheduling 工作的排班或者CPU的排班) 技術達成</p>
<p>e.g. 當執行中的process在waiting for I/O completed，則 OS 可以將 CPU 切換給另外一個 process 執行，避免 CPU idle</p>
<p>即只要系統內有夠多的 Jobs 存在，則 CPU idle 機會下降</p>
<p>(二）Multiprogramming Degree</p>
<p>相當於<!-- raw HTML omitted -->系統內之 processes 數目<!-- raw HTML omitted --></p>
<p>一般而言，如果 Degree 越高，則 cpu utilization 越高</p>
<p>Note: Chapter 8 virtual memory Thrashing 例外狀況除外</p>
<p>(三）多個 processes 同時執行之方式有兩個：</p>
<ol>
<li>
<p>Concurrent execution 並行</p>
<p>一顆CPU，大家輪流交錯使用，晚上7-8點給P1，做不下去切給其他的</p>
</li>
<li>
<p>Parallel execution 平行</p>
<p>多顆CPU或者多核 (core) ，每一個工作都在不同的cpu平行執行</p>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/JTe4SFh.png"
        data-srcset="https://i.imgur.com/JTe4SFh.png, https://i.imgur.com/JTe4SFh.png 1.5x, https://i.imgur.com/JTe4SFh.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/JTe4SFh.png"
        title="image-20240126144825311" /></p>
<blockquote>
<p>Multiprogramming 跟一顆cpu或者多顆cpu無關，單一 user 也可以 multiprogramming，不限定多個 users。</p>
<p>允許多個工作同時進行就稱為 multi-programming。</p>
</blockquote>
<h1 id="02-time-sharing-system-分時系統">02. Time-Sharing System 分時系統</h1>
<blockquote>
<p>Time-Sharing騙局 - 讓每個user都以為有一台 dedicated to myself 的 computer</p>
</blockquote>
<p>(一）Def: 恐龍本又稱為Multitasking</p>
<p>“It&rsquo;s a logical extension of multiprogramming system.”</p>
<p>與Multiprogramming的最大差異：<strong>CPU的切換頻率極高</strong> (CPU switching highly frequently)</p>
<p>Time-sharing system features 還有：</p>
<ol>
<li>
<p>強調對user的response time要短（e.g. &lt; 一秒）</p>
</li>
<li>
<p>適用於 “user interactive” computing/environment (一來一往的使用者互動)</p>
</li>
<li>
<p>CPU scheduling（CPU排班）採用 RR 排班法則 (ch4)</p>
</li>
<li>
<p>Memory有限，如何讓user覺得電腦都是他們專屬使用呢？</p>
<p>使用virtual memory技術，擴展 “logical memory space”</p>
</li>
<li>
<p>使用“spooling”技術實現I/O Devices的共用，</p>
</li>
</ol>
<p><strong>Mainframe</strong>（主機, 例如IBM的vex360、vex370）</p>
<p>銀行的外匯交易、貨幣準備金、遠程外匯交割都在這上面實施，因為造價很貴，所以常會從主機拉終端機 (terminal) 出來，通常是terminal+keyboard很多台</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/DdzGIP1.png"
        data-srcset="https://i.imgur.com/DdzGIP1.png, https://i.imgur.com/DdzGIP1.png 1.5x, https://i.imgur.com/DdzGIP1.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/DdzGIP1.png"
        title="image-20240126150020729" /></p>
<p>掃毒軟體、下載都不是屬於 user interactive 的情況</p>
<p>因為交易要經過一連串的互動才會完成，所以要求 response time 短</p>
<p>RR排班可以讓 cpu 使用對不同的 user 保障公平，也造就切換頻率高</p>
<p>不管你程式寫多大，我都讓你執行，邏輯的記憶體無窮寬廣</p>
<p><strong>Physical Memory</strong> (e.g. RAM) v.s. <strong>Logical Memory</strong></p>
<p>* Logical 通常是指使用者這一端</p>
<p>user看記憶體 - logical memory</p>
<p>user看檔案目錄 - logical directory 邏輯的目錄</p>
<p>作業系統在管理檔案配置的目錄，那個就叫做實體目錄 &hellip; (memory disk詳談)</p>
<p>Spooling - 把磁碟當成極大的緩衝區，類似於現在的 buffer 技術（工作原理大同小異）</p>
<p>Spooling示例：</p>
<ol>
<li>
<ol>
<li>user下達列印xxx檔案的命令</li>
</ol>
</li>
<li>
<ol start="2">
<li>把這個檔案送到磁碟disk</li>
</ol>
</li>
<li>
<ol start="3">
<li>系統告訴你列印完成（事實上還沒開始印，系統不會通知你在queue的第幾順位）</li>
</ol>
</li>
<li>
<ol start="4">
<li>接下來printer才一個一個開始印</li>
</ol>
</li>
</ol>
<p>在這種環境裡頭，user最care的就是回應時間 (response time)</p>
<p>假使一個中繼結果不需要user的反饋，最好也是要回覆給user</p>
<p>非本科系學生等待時間平均七秒 &hellip; enter/esc/ctrl+c/ctrl+break …</p>
<p>而本科系比較長，會給他解釋的時間 &hellip; 網路擁塞、主機今天交易多 &hellip;</p>
<blockquote>
<p>銀行系統如果正常要4秒鐘回來的話</p>
<p>超過一般的標準時間之後就要抽一張詞</p>
<p>『系統正在處理中，今日業務稍多，請不要中斷 &hellip;』</p>
<p>『今日系統交易異常繁忙，您可以考慮取消或者再等待一下，即將有結果 &hellip;』</p>
<p>『今日電信網路故障 &hellip;』</p>
</blockquote>
<h1 id="03-multiprocessors-system">03. Multiprocessors system</h1>
<p>(一）Def: 又叫 Multiprocessing system or Parallel system or Tightly-Coupled system (緊密耦合的系統)</p>
<p>主要特徵 (features) 如下：</p>
<p>(1) 一個機器 (or Motherboard) 內有多顆 processors (or CPUs)</p>
<p>(2) 這些 CPUs 彼此共享此機器的 Memory、Bus、I/O-Devices、power-supplier, etc.</p>
<p>(3) 通常受同一個 clock 之時脈控制</p>
<p>(4) 由 同一個 OS 管理</p>
<p>(5) processors 之間的溝通大都採 “shared memory” 方式 (ch6詳談)</p>
<p>【圖示】</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/TYVtMJa.png"
        data-srcset="https://i.imgur.com/TYVtMJa.png, https://i.imgur.com/TYVtMJa.png 1.5x, https://i.imgur.com/TYVtMJa.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/TYVtMJa.png"
        title="image-20240126150547935" /></p>
<p>(二）Benefits（好處）:</p>
<p>(1) Increased Throughput 產能增加</p>
<p>(2) Increased Reliability 可靠度提升</p>
<p>(3) Economy of Scale 運算能力擴充時符合經濟效益</p>
<p><strong>產能增加</strong>，可以支持多個工作在不同CPUs上平行執行 (parallel computing)</p>
<p>Note: 雖然可以增加產能，但N顆CPUs的產能絕對小於原來一顆CPU產能*N倍</p>
<p>​    原因有二：&lt;1&gt; Resource competition資源競爭，兩顆CPU等一個bus</p>
<p>​            &lt;2&gt; Processors之間的Communication會抵銷產能</p>
<p><strong>可靠度提升</strong>，萬一若某個CPU壞了，則system不會因而停頓，因為還有其它CPUs仍可以運行</p>
<p>Note: 名詞解釋 &lt;1&gt; Graceful degradation 漸進式滅亡</p>
<p>​              系統不會因為某些HW/SW元件故障而停頓，仍然保有持續運作之能力，</p>
<p>​              此性質稱為 graceful degradation，又稱為 Fail-Soft 軟失敗</p>
<p>​           &lt;2&gt; Fault-Tolerant system 容錯系統</p>
<p>​              具有graceful degradation性質的系統，稱為fault-tolerant system</p>
<p>達成容錯技術要符合兩條件: Backup system獨立系統&gt;=2｜Switching smoothly無縫平穩切換</p>
<p><strong>運算能力之擴充，符合經濟效益</strong></p>
<p>比較基準：N顆CPUs在一部機器內，與N部機器相比，成本較為便宜。因爲這些CPU共享同一個機器裡頭的 Memory, Bus, I/O-Devices, etc.</p>
<p>(三）Multiprocessors system 可以再細分為兩種 subtypes</p>
<p>(1) SMP (Symmetric MultiProcessors) 對稱</p>
<ul>
<li>
<p>定義：每一個processor之工作能力是相同的（identical）</p>
<p>每一個CPU皆有對等的權利來存取資源</p>
</li>
<li>
<p>優點：1️⃣ 可靠度較ASMP高      2️⃣ 效能較高</p>
</li>
<li>
<p>缺點：SMP的<!-- raw HTML omitted -->OS設計開發較為複雜<!-- raw HTML omitted -->，例如互斥存取之機制的設計</p>
</li>
</ul>
<p>(2) ASMP (Asymmetric MultiProcessors) 非對稱</p>
<ul>
<li>
<p>定義：每個processor之工作能力不盡相同，通常採取“Master-Slave”架構 (恐龍本: Boss-Employee)，Master processor 負責工作分派以及資源分配，監督 slaves 等管理性工作；其它 slave processor 負責執行工作</p>
</li>
<li>
<p>優點：ASMP的OS設計開發較為簡單，因為他跟simple-CPU的OS版較為類似，開發容易，成本較低</p>
</li>
<li>
<p>缺點：1️⃣ 相較於SMP的可靠度較低</p>
<p>​              2️⃣ 效能較低（因為Master CPU是瓶頸）</p>
<p>多個slaves與master各有大量訊息交換，master做決策，行政效率較差，如果是為了搶市場，通常會先推 ASMP</p>
</li>
</ul>
<p>(四）Multiprocessors system v.s. MultiCores CPU (多核）</p>
<ul>
<li>
<p>主要是硬體的差異；就OS而言，沒有差異</p>
</li>
<li>
<p>將一個Core視為logical CPU來看待</p>
</li>
<li>
<p>例：主機板裝了四顆雙核的CPUs，對OS而言，即是有 4*2 = <strong>8</strong> 顆CPUs可用</p>
</li>
<li>
<p>優點</p>
<p>‧ Power saving</p>
<p>‧ 速度較快</p>
<p>(同一個晶片內資料的傳輸速度)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/EPOxKdr.png"
        data-srcset="https://i.imgur.com/EPOxKdr.png, https://i.imgur.com/EPOxKdr.png 1.5x, https://i.imgur.com/EPOxKdr.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/EPOxKdr.png"
        title="image-20240126151044539" /></p>
</li>
</ul>
<h1 id="distributed-system-分散式系統">Distributed system 分散式系統</h1>
<p>(一）</p>
<ul>
<li>
<p>定義：又叫 <!-- raw HTML omitted -->Loosely-Coupled<!-- raw HTML omitted --> system 鬆散耦合</p>
</li>
<li>
<p>主要特徵如下：</p>
<ol>
<li>
<p>多部機器彼此透過 network (LAN, WAN, etc.)（or Bus）相互串連</p>
</li>
<li>
<p>每部機器之CPU有各自私有的Memory, Bus, I/O-Devices, etc. 並非共享</p>
</li>
<li>
<p>各個CPU之clock時脈控制不一定相同</p>
</li>
<li>
<p>各個CPU上的OS也不見得相同 (你Linux, 我Mac, 它Windows)</p>
</li>
<li>
<p>各個processors之間的溝通大都採用“<!-- raw HTML omitted -->Message Passing<!-- raw HTML omitted -->”方式</p>
<p>Step1: 建立通訊鏈結 communication link</p>
<p>Step2: Message 訊息之間相互傳輸</p>
<p>Step3: 釋放 link</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/kMYropH.png"
        data-srcset="https://i.imgur.com/kMYropH.png, https://i.imgur.com/kMYropH.png 1.5x, https://i.imgur.com/kMYropH.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/kMYropH.png"
        title="image-20240126151528731" /></p>
</li>
</ol>
</li>
</ul>
<p>(二）構建分散式系統之理由（好處）</p>
<ol>
<li>
<p>Increased Throughput - 因為它支持平行運算 parallel computing</p>
</li>
<li>
<p>Increased Reliability</p>
</li>
<li>
<p><!-- raw HTML omitted -->Resource Sharing<!-- raw HTML omitted --> - 因為資源共享，導致成本降低</p>
<ul>
<li>說明：支持 “client-server” computing model 之實施</li>
<li>Server: 提供某些服務的機器</li>
<li>e.g. MailServer, FileServer, Domain name server (DNS),</li>
<li>PrinterServer (早期), Computing server (提供高速運算能力的伺服器）</li>
<li>Client: 本身不提供服務，且它需要某些服務時，則發請求給 server</li>
<li>Server服務完，再將結果傳回client</li>
<li>Note: “peer-to-peer” model  peer - 同時具有 server 以及 client 的角色</li>
</ul>
</li>
<li>
<p><!-- raw HTML omitted -->Remote Sites Communication<!-- raw HTML omitted --> 需求被滿足</p>
<p>e.g. email, FTP via internet</p>
</li>
</ol>
<blockquote>
<p>#3 跟 #4 是 distributed system 有別於 multiprocessor system 擁有的好處</p>
</blockquote>
<h1 id="real-time-system-即時系統">Real-Time System 即時系統</h1>
<p>(一）分為兩種：</p>
<ol>
<li>Hard real time system</li>
<li>Soft real-time system</li>
</ol>
<p>(二）Hard real-time system</p>
<ul>
<li>
<p>定義：This system must ensure the critical tasks complete on time.  即工作必須在規定的時間限制內完成，否則即算失敗</p>
</li>
<li>
<p>舉例：軍事防衛系統、核能安控系統、工廠自動化生產、機器人控制，等等。</p>
<p>military defense, nuclear safety control, manufacturing automation, robot control</p>
</li>
</ul>
<p>【圖示】感測器：壓力、溫度、一氧化碳偵測、雷達、聲納</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/x902W2L.png"
        data-srcset="https://i.imgur.com/x902W2L.png, https://i.imgur.com/x902W2L.png 1.5x, https://i.imgur.com/x902W2L.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/x902W2L.png"
        title="image-20240126152400575" /></p>
<h4 id="設計考量">設計考量：</h4>
<ol>
<li>
<p>所有時間延遲之因素皆須納入考量，確保這些時間加總能滿足 (&lt;=) 時間deadline要求</p>
<p>例如：sensor data transmission 傳輸速度、運算速度、signal的傳輸</p>
</li>
<li>
<p>所有會造成處理時間過久或者無法預測之設備或機制，宜少採用或不用</p>
<p>例如：磁碟disk宜少用或不用（運作速度比較久）、 絕對不採用virtual memory</p>
</li>
<li>
<p>就 cpu scheduling 設計(ch4)而言，須先考量 schedulable 與否，再進行排程</p>
<p>例如：rate-monotonic, EDF scheduling (cpu排班設計在詳談）</p>
</li>
<li>
<p>Time sharing system 無法與之並存</p>
<p>肯定是走priority機制，不會RR scheduling</p>
</li>
<li>
<p>OS 所造成的任何 dispatch latency etc. 宜降低</p>
<p>Note：一般實務上，hard real-time system 鮮少有OS (OS幾乎不存在），尤其是 embedded real-time system（嵌入式的體積一定要小）</p>
</li>
<li>
<p>現行商用 OS 不支援 Hard real-time features，通常是客製化設計</p>
<p>（商用OS：Linux, Unix, Windows, AppleOS, Solaris, etc.)</p>
</li>
</ol>
<p>（三）Soft real-time system</p>
<ul>
<li>
<p>定義：This system must ensure <strong>the real-time process get the highest priority</strong> than the others, and <strong>retain this priority level</strong> until it completed.</p>
<p>要取得最高優先權，並且維持住不可衰退</p>
</li>
<li>
<p>舉例：Multimedia system, simulation system, VR system, etc.</p>
<p>工作有先後執行卡關的關係，例如先播音訊再放影片，科學模擬遵照步驟，等等</p>
</li>
<li>
<p>系統設計考量：</p>
<ol>
<li>
<p>就cpu scheduling設計 (ch4) 角度而言：</p>
<ol>
<li>必須支持 preemptive priority scheduling 可插隊優先權排班法則</li>
<li>不可以提供 “Aging” 技術（aging: 防止低優先權的 starvation, 逐步調高優先權）</li>
</ol>
</li>
<li>
<p>盡量降低 kernel 的分配延遲時間 Dispatch latency time (ch4)</p>
</li>
<li>
<p>可支援 virtual memory 並存，但是要求 real-time process 的全部頁面 (pages) 必須皆待在 memory 中，不可以被當作犧牲頁面 swapped out，直到完工</p>
</li>
<li>
<p>與 Time-sharing system 可以並存，例如：Solaris作業系統</p>
</li>
<li>
<p>一般商用系統 OS 皆支持 soft real-time system 的特徵</p>
<p>（改變一下OS架構參數，就可以達成以上要求）</p>
</li>
</ol>
</li>
</ul>
<h1 id="04batch-system-批次系統">04.Batch System 批次系統</h1>
<blockquote>
<p>Operating System 的前身為 resident monitor</p>
</blockquote>
<ul>
<li>
<p>定義：將一些<!-- raw HTML omitted -->較不緊急<!-- raw HTML omitted -->、<!-- raw HTML omitted -->定期性<!-- raw HTML omitted -->、<!-- raw HTML omitted -->非交談互動性<!-- raw HTML omitted -->之 jobs，累績成堆，再分批送入系統處理</p>
</li>
<li>
<p>舉例：庫存盤點、報稅、掃毒工作、磁碟重組、下載音樂、銀行清算系統等等</p>
</li>
<li>
<p>主要目的：</p>
<ul>
<li>提高 resource utilization，尤其是冷門時段/非尖峰時期的資源利用率</li>
<li>不適合用在 real-time system，或者user-interactive application (e.g. game)</li>
</ul>
</li>
</ul>
<h4 id="handheld-system-手持式系統">HandHeld system 手持式系統</h4>
<p>(一）舉例：PDA個人數位化助理、Smartphone智慧型手機、Pad平板</p>
<p>(二）Hardware天生之限制，帶來Software必須配合之處</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/Z9dD5mA.png"
        data-srcset="https://i.imgur.com/Z9dD5mA.png, https://i.imgur.com/Z9dD5mA.png 1.5x, https://i.imgur.com/Z9dD5mA.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/Z9dD5mA.png"
        title="image-20240126153137477" /></p>
<h1 id="05-io運作與hardwarehw-resources-protection">05. I/O運作與Hardware(Hw) resources Protection</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/JXjD5sC.png"
        data-srcset="https://i.imgur.com/JXjD5sC.png, https://i.imgur.com/JXjD5sC.png 1.5x, https://i.imgur.com/JXjD5sC.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/JXjD5sC.png"
        title="image-20240126153446919" /></p>
<h3 id="io-運作方式">I/O 運作方式</h3>
<h4 id="polling-io-詢問式-io">Polling I/O (詢問式 I/O)</h4>
<ul>
<li>
<p>定義：又稱為 Busy-waiting I/O (忙碌等待I/O) 或者 programmed I/O (可程式化I/O)</p>
</li>
<li>
<p>如下步驟：</p>
<ol>
<li>
<p>user process 發出 I/O-request</p>
</li>
<li>
<p>OS 收到請求後，(Blocking I/O或者Non-Blocking I/O可能）會暫停此 process 執行，並執行對應的 system calls</p>
</li>
<li>
<p>Kernel的I/O-subsystem會Pass此請求給<!-- raw HTML omitted -->Device driver (設備的驅動程式, Software (Sw))<!-- raw HTML omitted --></p>
</li>
<li>
<p>Device Driver依照此請求，設定對應的 I/O Commands 參數給 <!-- raw HTML omitted -->Device Controller (設備控制器(Hw))<!-- raw HTML omitted --></p>
</li>
<li>
<p>Device Controller 啟動，監督 I/O-Device 之 I/O 運作進行</p>
</li>
<li>
<p>在此之時，OS（可能）將 CPU 切給另外一個 process 執行</p>
</li>
<li>
<p>然而，cpu在執行process工作過程中，卻要不斷去polling Device Controller，以確定I/O運作是否完成或有I/O-error</p>
<blockquote>
<p>沒人告訴CPU其I/O做完了沒，設備控制器不會主動告知</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>缺點：</p>
<p>CPU 耗費大量時間 (80~90%) 用於 polling I/O Device Controller 上，並未全用於 process execution (10~20%)上，故 CPU utilization 低 (真正用在process execution的比例) ，throughput 不高</p>
</li>
</ul>
<p>【圖示】</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/RlOfzex.png"
        data-srcset="https://i.imgur.com/RlOfzex.png, https://i.imgur.com/RlOfzex.png 1.5x, https://i.imgur.com/RlOfzex.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/RlOfzex.png"
        title="image-20240126155133275" /></p>
<h4 id="interrupted-io-中斷式-io">Interrupted I/O (中斷式 I/O)</h4>
<p>運用中斷的技巧來處理I/O設備與CPU之間溝通的方式</p>
<ul>
<li>
<p>定義：步驟如下</p>
<ul>
<li>Step 1 ~ Step 6 同前面敘述</li>
<li>Step 7：當I/O運作完成，設備控制器會發出 “I/O-Completed” Interrupt 通知 OS (CPU)</li>
<li>Step 8：OS收到中斷之後，（可能）會先暫停目前Process的執行，如果中斷的優先權很低，或有更緊急的事要做，就可能先不處理這個中斷</li>
<li>Step 9：OS必須查詢 “Interrupt Vector”(中斷向量表)，確認何種中斷發生，同時也要找到該中斷的 ISR (Interrupt Service Routine，服務處理程式) 的位址</li>
<li>Step10：Jump to ISR 位址，執行 ISR</li>
<li>Step11：ISR 完成後，控制權返回 kernel (return control to kernel)，kernel 也許作一些通知工作</li>
<li>Step12：恢復（resume）原先中斷之前的工作執行，或交由 cpu scheduler 決定</li>
</ul>
</li>
<li>
<p>優點：</p>
<p>CPU不須耗費時間用於polling I/O-Device，而是可以用於process execution上。因此，CPU utilization有所提升，且提高了Throughput，改善了system performance</p>
</li>
<li>
<p>缺點：</p>
<ol>
<li>
<p>中斷的處理仍然需要耗費一些CPU的時間 (overhead)，所以若I/O運作時間 (開始-結束) 小於interrupt處理時間，則使用Interrupted I/O就不划算， 因此，polling I/O仍然有其必要性</p>
<blockquote>
<p>假設家裡是強力瓦斯爐，開水要燒滾只要一分鐘，從沙發回想笛音是什麼意思（查表, Interrupt處理）也要一分鐘 &hellip; 這樣用中斷就不划算，在旁邊等 (busy-waiting) 更佳</p>
</blockquote>
</li>
<li>
<p>若中斷發生的頻率太高，則大量的中斷處理，會佔用幾乎全部的cpu time，系統效能會很差</p>
<blockquote>
<p>例如找到一個完美的笛音壺但水量只有5ml，泡一杯咖啡要250ml（為了接下來的DMA鋪路）</p>
</blockquote>
</li>
<li>
<p>CPU 仍須耗費一些時間，用於監督/負責 I/O-Device 與記憶體之間的資料傳輸過程設備 (DiskRead/DiskWrite Buffer register）的資料傳輸到Memory是由 ISR 軟體執行 (Step10)，仍要消耗CPU時間</p>
<blockquote>
<p>該找瑪莉亞幫你泡咖啡了！</p>
<p>該存錢買咖啡機了！－<strong>DMA介入</strong></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>​</p>
<h4 id="dma-direct-memory-access-io">DMA (Direct Memory Access I/O)</h4>
<p>(一）定義：DMA controller負責I/O-Device與Memory之間的Data transfer資料傳輸工作，過程中無須CPU之參與監督，cpu有更多時間用於processor execution上</p>
<ul>
<li>
<p>優點：</p>
<ol>
<li>
<p>CPU utilization更高</p>
</li>
<li>
<p>適合用在Block-Transfer oriented I/O-Device (以區塊傳輸為導向的I/O設備) 上</p>
<p>代表中斷發生的頻率不至於過高</p>
<p>例：磁碟的控制器會與DMA控制器合作，這過程不需要cpu的監督</p>
<p>例：<strong>不</strong>適合用在Byte-Transfer oriented I/O-Device</p>
</li>
</ol>
</li>
<li>
<p>缺點：</p>
<ol>
<li>
<p>引進DMA controller會增加硬體設計的複雜度</p>
<p>Complicated the hardware design</p>
<p>原因：DMA Controller會與CPU競爭 (爭奪) Memory 以及 Bus 的使用權</p>
<p>當 DMA controller 佔用了 memory 或 bus 時，CPU 要被迫等待</p>
</li>
</ol>
</li>
</ul>
<h5 id="補充">[補充]</h5>
<ol>
<li>
<p>DMA Controller通常採用 “Cycle Stealing” 技術（或Interleaving (per the恐龍本)) 與CPU輪番交錯使用 memory 以及 bus。如果CPU與DMA controller發生conflict (衝突-同時要用memory以及bus)，則會給 <strong><!-- raw HTML omitted -->DMA<!-- raw HTML omitted --></strong> 比較高的優先權。</p>
<blockquote>
<p>瑪莉亞不僅會泡咖啡，還會燒菜！</p>
</blockquote>
</li>
<li>
<p>通常系統會給予 “對該資源需求量、頻率等較<strong>小</strong>” 的對象有較高的優先權</p>
<p>會獲得1️⃣平均等待時間較小 2️⃣平均產能比較高 的好處</p>
<blockquote>
<p>最短工作優先</p>
</blockquote>
</li>
</ol>
<h1 id="06-機器指令-stages">06. 機器指令 Stages</h1>
<ol start="3">
<li>
<p>機器指令 Stages FO：Fetch Operand</p>
<ul>
<li>有記憶體變數，立即/直接/相對定址</li>
</ul>
<table>
<thead>
<tr>
<th>IF</th>
<th>DE</th>
<th>FO</th>
<th>EX</th>
<th>WM</th>
</tr>
</thead>
<tbody>
<tr>
<td>instruction Fetch</td>
<td>Decode</td>
<td>Fetch Operand</td>
<td>Execution</td>
<td>Write result to Memory</td>
</tr>
<tr>
<td>抓指令</td>
<td>解OP code</td>
<td>抓運算元</td>
<td>執行</td>
<td>寫入資料進記憶體變數</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>CPU會Memory Access</th>
<th>DMA要用Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>IF</td>
<td>會（必要）</td>
<td>衝突 (Conflict, 爭奪memory)</td>
</tr>
<tr>
<td>DE</td>
<td>不會</td>
<td>OK</td>
</tr>
<tr>
<td>FO</td>
<td>可能會</td>
<td>OK或者有衝突（如果有衝突的時候，會給予DMA比較高的優先權)</td>
</tr>
<tr>
<td>EX</td>
<td>不會</td>
<td>OK</td>
</tr>
<tr>
<td>WM</td>
<td>可能會（有可能會用memory, 也可能不用）</td>
<td>OK或者有衝突</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h4 id="dma之six-steps圖示">DMA之six steps圖示</h4>
<ol>
<li>
<p><!-- raw HTML omitted -->Device driver<!-- raw HTML omitted --> is told to transfer disk data to <!-- raw HTML omitted -->buffer<!-- raw HTML omitted --> address X</p>
<p>設備驅動程式被告知要傳輸資料到記憶體buffer，Buffer之起始位置為 X</p>
</li>
<li>
<p><!-- raw HTML omitted -->Device driver<!-- raw HTML omitted --> tells <!-- raw HTML omitted -->disk controller<!-- raw HTML omitted --> to transfer C bytes from disk to Buffer at address X</p>
<p>設備驅動程式告知磁碟控制器, 從磁碟裡傳輸C bytes的量進buffer add.3</p>
</li>
<li>
<p><!-- raw HTML omitted -->Disk controller<!-- raw HTML omitted --> initiates DMA transfer</p>
</li>
<li>
<p><!-- raw HTML omitted -->Disk controller<!-- raw HTML omitted --> sends each byte to DMA controller</p>
</li>
<li>
<p>DMA transfer bytes to Buffer X increasing memory address (X+1) and decreasing C until C=∅ (C byte的量, counter C-1)</p>
</li>
<li>
<p>When C = ∅, DMA interrupts CPU to signal transfer completion</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/WVnkbbc.png"
        data-srcset="https://i.imgur.com/WVnkbbc.png, https://i.imgur.com/WVnkbbc.png 1.5x, https://i.imgur.com/WVnkbbc.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/WVnkbbc.png"
        title="image-20240126160627526" /></p>
</li>
</ol>
<h4 id="life-cycle-of-io-request-via-interrupted-io">Life cycle of I/O-request via Interrupted I/O</h4>
<p>(經由中斷式I/OS) 之I/O請求的生命週期</p>
<p><!-- raw HTML omitted -->🚧 這段不太懂 35:34 - 50:21 (06)<!-- raw HTML omitted --></p>
<h1 id="07-blocking-and-non-blocking-io">07. Blocking and Non-Blocking I/O</h1>
<ol>
<li>
<p>Blocking-I/O: Process suspended until I/O completed</p>
<ul>
<li>
<p>發出請求之後暫停，直到I/o完成後才繼續process</p>
</li>
<li>
<p>優：Easy to use and understand</p>
</li>
<li>
<p>缺：Insufficient for some needs</p>
</li>
</ul>
</li>
<li>
<p>Non-Blocking I/O:</p>
<p>播放電影的時候，總共有1GB，先抓取2mb的資料 [ 20:51 的圖有改版🚧 ]</p>
<ul>
<li>
<p>I/O calls returns as much as available</p>
<p>e.g. user interface data copy (buffered I/O)</p>
</li>
<li>
<p>Implemented via multi-threading</p>
</li>
<li>
<p>Returns quickly with count of bytes read or written</p>
</li>
</ul>
</li>
<li>
<p>Asynchronous I/O:</p>
<p>Process runs while I/O executes</p>
<ul>
<li>
<p>Difficult to use</p>
</li>
<li>
<p>I/O subsystem signals process when I/O completed</p>
<p>發送I/O request之後，控制權馬上還給user process</p>
<p>發送在執行，I/O設備也在執行</p>
</li>
</ul>
</li>
</ol>
<p>【圖示】</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/pgPdJ4W.png"
        data-srcset="https://i.imgur.com/pgPdJ4W.png, https://i.imgur.com/pgPdJ4W.png 1.5x, https://i.imgur.com/pgPdJ4W.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/pgPdJ4W.png"
        title="image-20240126161629760" /></p>
<h5 id="小差異">小差異：</h5>
<ul>
<li>
<p>Non-blocking I/O:</p>
<p>I/O 完成資料有多少就丟多少回來(即少量 returns as much as possible)</p>
<p>要求讀100bytes，每25bytes, kernel 就會通知process</p>
</li>
<li>
<p>Asynchronous I/O:</p>
<p>整個I/O完成，才通知process</p>
<p>讀完整個100bytes完成後才通知process</p>
</li>
</ul>
<h4 id="interrupt機制與種類">Interrupt機制與種類</h4>
<p>（一）當Interrupt發生，OS之處理步驟如下：</p>
<ol>
<li>
<p>OS收到中斷後，（若此中斷要被立即處理的話）則OS會暫停目前Process之執行，且保存其 Status and Registers Contents</p>
</li>
<li>
<p>OS會依 Interrupt ID.(No.) 去查詢中斷向量表 (interrupt vector) 確認何種中斷發生，並且找出其 ISR 的位址</p>
</li>
<li>
<p>Jump to ISR位址，執行ISR</p>
</li>
<li>
<p>ISR 完成之後，控制權返回 kernel</p>
</li>
<li>
<p>OS 會恢復（resume）中斷之前 process 之執行</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/bJv8atO.png"
        data-srcset="https://i.imgur.com/bJv8atO.png, https://i.imgur.com/bJv8atO.png 1.5x, https://i.imgur.com/bJv8atO.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/bJv8atO.png"
        title="image-20240126162224778" /></p>
</li>
</ol>
<p>（二）Interrupt種類 ✨✨</p>
<ul>
<li>
<p><strong>[分類一]</strong> 分為三種：</p>
<ol>
<li>
<p>External interrupt 外部中斷:</p>
<p>CPU以外的周邊設備，控制卡，etc. 所發出來的</p>
<p>例如：”I/O Completed”, “I/O-error”, “machine-check”</p>
</li>
<li>
<p>Internal interrupt:</p>
<p>CPU在執行Process過程中，遭遇重大錯誤而引發</p>
<p>例如：Divide-by-zero, 執行非法的特權指令, etc.</p>
</li>
<li>
<p>Software interrupt:</p>
<p>user process 在執行中，若須要OS提供服務時，必須發出此類中斷，</p>
<p>目的是通知作業系統，請它執行對應的服務請求</p>
<p>例如：I/O-request</p>
<p>Note: 好比是“服務鈕”</p>
</li>
</ol>
</li>
<li>
<p><strong>[分類二]</strong> Interrupt 與 Trap兩種</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/SIlx8FA.png"
        data-srcset="https://i.imgur.com/SIlx8FA.png, https://i.imgur.com/SIlx8FA.png 1.5x, https://i.imgur.com/SIlx8FA.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/SIlx8FA.png"
        title="image-20240126163005722" /></p>
<ul>
<li>
<p>例：設備發出“I/O-Completed”, “I/O-error”, “machine-check”, etc.  以及 “Time-out” by Timer（硬體計時器）</p>
</li>
<li>
<p>Trap 用途主要有二：</p>
<ol>
<li>
<p>Catch the arithmetic error 程式執行遭遇重大錯誤</p>
<p>例如：Divide-by-zero、執行非法的特權指令（該指令不該是你執行）、illegal memory access</p>
</li>
<li>
<p>user process執行須要OS提供服務時，也會發Trap通知OS</p>
<p>例如：I/O-request</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>[分類三]</strong> 分為兩類              <code>中斷之間也有優先權高低</code></p>
<ol>
<li>
<p><strong>maskable interrupt</strong> 可遮罩中斷：</p>
<p>此類中斷發生可以被忽略 (ignored, 假裝沒聽到) 或延後處理 (queued, 知道了, 打完就去)，不一定要馬上處理</p>
<p>e.g. Software interrupt (優先權較低)</p>
</li>
<li>
<p><strong>non-maskable interrupt</strong> 不可遮罩中斷：</p>
<p>此類中斷必須立刻處理，通常比較緊急</p>
<p>e.g. internal interrupt（程式執行遭遇重大錯誤）, I/O-error, etc.</p>
</li>
</ol>
</li>
</ul>
<h4 id="hardware-resources-protection-硬體資源保護">Hardware Resources Protection 硬體資源保護</h4>
<p>〖基礎建設〗</p>
<ul>
<li>必須要先有這兩種東西：
<ol>
<li>Dual-modes operation 雙重模式運作</li>
<li>Privileged instructions</li>
</ol>
</li>
</ul>
<h4 id="dual-modes-operation">Dual-modes operation</h4>
<p>（一）定義：system 之運作模式至少要可以被區分為兩種模式</p>
<ol>
<li>
<p>kernel mode:</p>
<ul>
<li>
<p>又叫作 system mode, supervisor mode, 也有人稱之為privileged mode</p>
<p>（早期有，現移除的 monitor mode）</p>
</li>
<li>
<p>代表此刻是 kernel 取得系統的控制權（i.e. 取得CPU執行)</p>
</li>
<li>
<p>允許特權的指令 (privileged instructions) 在此模式下執行</p>
</li>
</ul>
</li>
<li>
<p>user mode:</p>
<ul>
<li>代表user process取得CPU執行，此模式下<strong>不允許</strong>執行特權指令，若執行產生Trap</li>
</ul>
</li>
</ol>
<blockquote>
<p>此外，dual-modes 必須要有硬體的支持才可實現</p>
<p>例如：CPU內會有Mode Bit，用以區分現在是哪個模式</p>
</blockquote>
<h5 id="privileged-instruction特權指令">Privileged instruction（特權指令）</h5>
<ul>
<li>
<p>定義：</p>
<p>任何可能會造成系統重大危害的指令，可以設為特權指令</p>
<p>特權指令只可以在 kernel mode 執行，不可以在 user mode 執行，</p>
<p>一旦在 user mode 下執行，會發生 Trap 通知 OS，將此 user process terminates</p>
</li>
<li>
<p>例如</p>
<ul>
<li>
<p>Turn-off（disable) interrupt 把中斷的機制關掉</p>
</li>
<li>
<p>Clear memory</p>
</li>
<li>
<p>I/O-instructions (for I/O protection)</p>
</li>
<li>
<p>Timer 值 Set / change (for CPU protection)</p>
</li>
<li>
<p>Base/limit register 修改/set (for memory protection)</p>
</li>
<li>
<p>Change mode from user mode to kernel mode</p>
</li>
</ul>
</li>
</ul>
<h5 id="quests">Quests</h5>
<ul>
<li>
<p>下列哪些是特權指令？</p>
<p>(1) Set value of Timer</p>
<p>(2) Read the clock</p>
<p>(3) Clear Memory</p>
<p>(4) Turn off interrupt</p>
<p>(5) Switch from user to monitor mode</p>
<blockquote>
<p>Ans: (1)(3)(4)(5)</p>
</blockquote>
</li>
<li>
<p>保護作業系統是至關重要的事情，因為要做到這樣的保護，才會有Dual-Modes</p>
<p>然而為了讓user flexibility最大化，對user process的限制也要越少越好，</p>
<p>以下七條通常可以被列入特權指令，但有些好像不太需要，哪些必須？</p>
<p>(1) Change to user mode</p>
<p>(2) Change to monitor mode</p>
<p>(3) Read form monitor memory</p>
<p>(4) Write into monitor memory</p>
<p>(5) Fetch an instruction from monitor memory</p>
<p>(6) Turn on timer interrupt</p>
<p>(7) Turn off timer interrupt</p>
<p>Ans: to be discussed</p>
</li>
</ul>
<p>為何構成protection之基礎 &hellip;</p>
<ol>
<li>[User Mode] user process 透過 Trap 發出請求</li>
<li>[Mode change] to kernel mode</li>
<li>[Kernel mode] kernel 執行 I/O 指令 / 特權指令</li>
<li>I/O 指令 / 特權指令將結果傳回 kernel</li>
<li>[Mode change] to user mode</li>
<li>將結果傳回 user process</li>
</ol>
<h4 id="hardware-resources-protection">Hardware Resources Protection</h4>
<ol>
<li>I/O protection</li>
<li>Memory protection</li>
<li>CPU protection</li>
</ol>
<h5 id="io-protection">I/O Protection</h5>
<ul>
<li>
<p>目的：由於I/O運作較為繁瑣複雜，為了<strong>降低 user processes 操控 I/O 之複雜度</strong>，及避免user process 對 I/O Devices 之不當操作，所以才有 I/O protection</p>
</li>
<li>
<p>作法：將所有 I/O 指令設為特權指令 (privileged instruction)，配合 Dual Modes，<strong>一律讓 user process 委託 kernel 執行 I/O 運作</strong></p>
</li>
</ul>
<h5 id="memory-protection">Memory Protection</h5>
<ul>
<li>
<p>目的：防止 user process 存取其它 user processes 之 memory area 及 kernel memory area</p>
</li>
<li>
<p>作法：（以Contiguous Memory Allocation為例）</p>
<p>針對每一個 process，kernel 會提供一套 Registers，稱為 Base/Limit Register</p>
<p>其中 Base register: 記錄 Process 之<strong>起始位址</strong></p>
<p>​          Limit register: 紀錄 Process 之<strong>大小</strong></p>
<p>將來，Process執行，會進行下列的checking:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/wvzvDdh.png"
        data-srcset="https://i.imgur.com/wvzvDdh.png, https://i.imgur.com/wvzvDdh.png 1.5x, https://i.imgur.com/wvzvDdh.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/wvzvDdh.png"
        title="image-20240126165148804" /></p>
<p>檢查memory位址是否大於等於 Base(起始位址, e.g. base=1000)，如果小於base則為非法的記憶體存取，接著確認最後一個合法的位址為何 (if Base = 1000, limit = 500) ?</p>
<p>最後位址 = 1000 + 500 - 1 = 1499</p>
<p>若 memory 位址不小於 Base + limit，則也是非法的記憶體存取</p>
<p>以上兩項檢查由硬體完成，Hardware = MMU (記憶體管理單元, Memory Management Unit)</p>
<p>此外，Base與Limit register值之set/change須設為“特權指令”</p>
</li>
</ul>
<h5 id="cpu-protection">CPU Protection</h5>
<ul>
<li>
<p>目的：防止 user process 無限期/長期佔用 CPU，而不釋放</p>
</li>
<li>
<p>作法：</p>
<p>利用 Timer 實施，同時 OS 會規定 process 使用 CPU 時間之最大配額值 (Maximum Time Quantum) 當 process 取得 CPU 之後，Timer 初值即設為 maximum time quantum 值，隨著 process 實行時間增加，Timer 值會逐步遞減，直到 Timer 值為零，Timer 會發出Time-Out” interrupt 通知 OS，OS 便可強迫此 process 放掉 CPU。</p>
<p>此外，Timer值之set/change（設定/修改）也須設為特權指令。</p>
</li>
</ul>
<h2 id="ch3-os之development">Ch3. OS之Development</h2>
<ul>
<li>
<p>OS應提供的服務項目 (3-5, 3-6 what is the OS? What r the services provided by OS?)</p>
</li>
<li>
<p>OS之服務元件種類 (3-3)</p>
</li>
<li>
<p>System Calls之介紹 🌠</p>
</li>
<li>
<p>OS之Structure種類 (🌠作業系統模組之間的架構）</p>
<ul>
<li>Simple                                          (e.g. DOS)</li>
<li>More Complex than simple (e.g. UNIX)</li>
<li><strong>Layered</strong> Approach                (e.g. OSI 7層)</li>
<li><strong>Microkernel</strong> 🌠微核心       (e.g. Mach)</li>
<li>Module                                         (e.g. 只收需要的)</li>
<li>Hybrid。                                      (e.g. 上述無法分類）</li>
</ul>
</li>
<li>
<p>架構設計原則：policy 與 mechanism 宜分開</p>
<ul>
<li>policy策略 - 要呈現什麼行為 what</li>
<li>mechanism機制 - 怎麼做出這個行為 how</li>
</ul>
</li>
<li>
<p>Virtual Machine 介紹：一開始是為了測試開發完的OS</p>
</li>
<li></li>
</ul>
<h5 id="軟體系統設計的兩大命題">〖軟體系統設計的兩大命題〗</h5>
<ul>
<li>
<p>高內聚：同樣或類似的功能越聚在一起越好</p>
</li>
<li>
<p>低耦合：模組之間的關聯性要越低越好</p>
</li>
</ul>
<blockquote>
<p>系統分析</p>
<p>軟體工程</p>
<ul>
<li>
<p>Waterfall</p>
<ul>
<li>
<p>Analysis 分析/瞭解需求</p>
</li>
<li>
<p>Design</p>
<ul>
<li>
<p>架構</p>
</li>
<li>
<p>細部設計 Algo + DS</p>
</li>
</ul>
</li>
<li>
<p>U.I.</p>
</li>
</ul>
</li>
<li>
<p>Coding/Implementation</p>
</li>
<li>
<p>Testing</p>
</li>
<li>
<p>Maintain</p>
</li>
</ul>
</blockquote>
<h1 id="09-system-call">09. System call</h1>
<ul>
<li>
<p>定義：</p>
<ul>
<li>
<p>作為執行中user proess與kernel之間的溝通界面，當user process須要OS提供某種服務時，會先trap通知OS，並代入system call ID(No.) 以及所須參數，接著，OS執行對應的system call，完成後，將服務結果return to user process</p>
</li>
<li>
<p>It&rsquo;s a programing interface to the services provided by the O.S.</p>
</li>
<li>
<p>Note: 類比</p>
<ul>
<li>Trap =&gt; 服務鈕（包廂服務鈴)</li>
<li>System call =&gt; 服務項目（KTV_kernel叫車,點餐,送BDC,作餐等20種服務）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【圖示】</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/GW2DMdB.png"
        data-srcset="https://i.imgur.com/GW2DMdB.png, https://i.imgur.com/GW2DMdB.png 1.5x, https://i.imgur.com/GW2DMdB.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/GW2DMdB.png"
        title="image-20240126170503851" /></p>
<blockquote>
<p>User process引發system call(<code>open()</code>)，引發sys.call一定伴隨Trap，sys.Call界面查表，執行對應的指令，實作後回傳結果</p>
<p>C library 查 printf 對應的 table，System Call Interface通常是走API規格</p>
</blockquote>
<ul>
<li>
<p>System call 作業系統提供的服務項目種類. (3-8 ~ 3-9)</p>
<ol>
<li>
<p><strong>Process Control</strong></p>
<p>e.g. 建立, 終止, 暫停, 恢復執行process, set/read attribute</p>
</li>
<li>
<p><strong>File Management</strong></p>
<p>e.g. 建立, 讀檔, 寫檔, 開檔, 關檔, 更改檔名, 變更檔案指標, 刪除</p>
</li>
<li>
<p><strong>Device Management</strong></p>
<p>設備管理</p>
</li>
<li>
<p><strong>Information of Maintenance</strong></p>
<p>e.g. 取得系統日期/時間, 取得process屬性等等</p>
</li>
<li>
<p><strong>Communications</strong></p>
<p>程序process之間的通訊, 而且只針對“message passing”方式提供服務</p>
</li>
<li>
<p><strong>Protections</strong></p>
<p>硬體資源的保護, 檔案存取權利的控制HW resources protection, File access control, etc.</p>
</li>
</ol>
</li>
<li>
<p>System call 之參數 (parameters) 傳遞的三種方式</p>
<ol>
<li>
<p>利用<strong>暫存器</strong> (Registers) 保存參數</p>
<ul>
<li>
<p>優點：(1) 最簡單 (2) 存取速度最快 (without memory access)</p>
</li>
<li>
<p>缺點：不適用於大量參數之情況</p>
</li>
</ul>
</li>
<li>
<p>利用 <strong>Memory</strong>，以 Block (Table) 儲存這些參數，並且將此表格的起始位置於一個 register 中，pass 給 OS</p>
<ul>
<li>
<p>優點：適用於大量參數</p>
</li>
<li>
<p>缺點：存取速度比較慢 (need memory access)，且操作較為麻煩</p>
</li>
</ul>
</li>
<li>
<p>利用 Stack (系統的堆疊）將參數push入此Stack，OS再 pop from Stack，以取得參數</p>
<ul>
<li>
<p>優點：也適用於大量參數之狀況，操作也簡單</p>
</li>
<li>
<p>缺點：堆疊Stack空間要留大一點，否則可能會overflow，堆疊如果平均少量，用暫存器；如果大量，就用記憶體</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="os之系統架構-structure-分類">OS之系統架構 (Structure) 分類</h4>
<ol>
<li>
<p><strong>Simple</strong></p>
<p>例：MS-DOS (resident system program, device driver, etc. 無dual-mode設計)</p>
</li>
<li>
<p>More complex than simple</p>
<p>例：UNIX</p>
<ul>
<li>Limited by Hardware functionality 受限於硬體功能性</li>
<li>The original UNIX had limited structuring</li>
<li>The UNIX包含兩個separate parts:
<ol>
<li>System Programs</li>
<li>The kernel</li>
</ol>
</li>
<li>Beyond simple but not fully layered</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/Gb4MPfz.png"
        data-srcset="https://i.imgur.com/Gb4MPfz.png, https://i.imgur.com/Gb4MPfz.png 1.5x, https://i.imgur.com/Gb4MPfz.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/Gb4MPfz.png"
        title="image-20240126171044726" /></p>
</li>
<li>
<p><strong>Layered approach</strong></p>
<ul>
<li>
<p>定義：</p>
<ol>
<li>
<p>採取 Top-Down 方式切割系統功能/元件，以降低複雜度</p>
</li>
<li>
<p>元件/模組之間依照呼叫關係分層，即上層可以使用下層功能，但下層不可以使用上層功能（上可以call下，下不能call上）</p>
</li>
<li>
<p>測試時使用 Bottom-up 方式來進行測試除錯，比較容易知道bug是落在哪一層</p>
</li>
<li>
<p>層次的劃分沒有明確規定，通常第零層是硬體，最外層是user interface</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/stqQdbu.png"
        data-srcset="https://i.imgur.com/stqQdbu.png, https://i.imgur.com/stqQdbu.png 1.5x, https://i.imgur.com/stqQdbu.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/stqQdbu.png"
        title="image-20240126171244198" /></p>
</li>
</ol>
</li>
<li>
<p>優點：</p>
<ol>
<li>降低設計複雜度</li>
<li>有助於分工</li>
<li>測試、除錯、維護容易</li>
</ol>
</li>
<li>
<p>缺點：</p>
<ol>
<li>
<p>很難做到很精確的層次劃分</p>
</li>
<li>
<p>若層次數太多，則系統效能可能會非常的差</p>
<p>If too many layer, then system performance would be very poor.</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>Microkernel</strong> 🌠 微核心</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/rVjyr8e.jpg"
        data-srcset="https://i.imgur.com/rVjyr8e.jpg, https://i.imgur.com/rVjyr8e.jpg 1.5x, https://i.imgur.com/rVjyr8e.jpg 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/rVjyr8e.jpg"
        title="image-20240126171721680" /></p>
<ul>
<li>
<p>由CMU（卡內基-美隆大學）率先提出，代表產品為 Mach O.S.</p>
</li>
<li>
<p>定義：將kernel中一些Non-essential services（比較不是那麼重要的服務）自kernel中移除（不在kernel mode中運行），改成在user side提供服務，在user mode中，以system programs的方式存在，如此一來，可以得到一個比較小的kernel，稱之為microkernel</p>
</li>
<li>
<p>一般而言，microkernel提供下列三個minimum services：</p>
<ol>
<li>Process control</li>
<li>Memory management（不包含virtual memory）</li>
<li>Process Communications（提供message passing服務而已）</li>
</ol>
</li>
<li>
<p>優點</p>
<ol>
<li>Easier to extend a microkernel</li>
<li>Easier to port the the O.S. to new architectures (硬體架構)</li>
<li>More reliable</li>
<li>More secure</li>
</ol>
<blockquote>
<p>說明如下：</p>
<p>1️⃣ 服務的增加跟刪除是容易的，因為這些服務是在user side執行，所以服務的增刪不須要牽扯到 kernel也要更動，即使要，也是小幅度修改</p>
<p>2️⃣ 因為kernel很小，所以作業系統移植到新的硬體平台之更動幅度不大</p>
<p>3️⃣＆4️⃣ 萬一某個服務在執行中掛掉了，充其量只是相當於一個 user process 掛掉而已，對hardware、kernel 以及其它 user processes 沒有不良影響，所以更加安全可靠</p>
</blockquote>
</li>
<li>
<p>缺點</p>
<p>Performance overhead of user space to kernel space communication</p>
<p>效能較差，因為充斥著大量user mode與kernel mode之間訊息的傳遞</p>
<blockquote>
<p>Microkernel的相反詞 <strong>Monolithic kernel</strong></p>
<p>定義：</p>
<ul>
<li>
<p>所有的services皆須run in kernel mode</p>
</li>
<li>
<p>大部分商用作業系統都是 monolithic kernel</p>
</li>
<li>
<p>Monolithic kernel之優缺點與微核心相反</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Module</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/ysuqo39.jpg"
        data-srcset="https://i.imgur.com/ysuqo39.jpg, https://i.imgur.com/ysuqo39.jpg 1.5x, https://i.imgur.com/ysuqo39.jpg 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/ysuqo39.jpg"
        title="image-20240126172335461" /></p>
<ul>
<li>
<p>Many OS implement loadable kernel modules</p>
</li>
<li>
<p>Use object-oriented approach</p>
</li>
<li>
<p>Each core component is separate</p>
</li>
<li>
<p>Each talks to the others over known interface</p>
</li>
<li>
<p>Each is loadable as needed within the kernel</p>
</li>
<li>
<p>簡記：Similar to layers but with more flexible, 效能也更好</p>
</li>
<li>
<p>Examples: Linux, Solaris, etc.</p>
</li>
</ul>
</li>
<li>
<p>Hybrid 混合型</p>
<ul>
<li>
<p>現代的作業系統很難存粹歸屬於某一型</p>
</li>
<li>
<p>例: Linux and Solaris 是 Monolithic (所有服務都在 kernel mode 運行）且也是Modular approach for dynamic loading</p>
</li>
<li>
<p>例: Windows mostly Monolithic, 有時針對不同客戶需求加上microkernel for subsystem</p>
</li>
<li>
<p>例: Apple MacOS 也是混合的，kernel包含：</p>
<ul>
<li>
<p>Mach: microkernel的代表</p>
</li>
<li>
<p>部分的 BSD UNiX</p>
</li>
<li>
<p>I/O kit</p>
</li>
<li>
<p>Dynamic loadable module (叫作 kernel extension)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/Y1SPbT0.png"
        data-srcset="https://i.imgur.com/Y1SPbT0.png, https://i.imgur.com/Y1SPbT0.png 1.5x, https://i.imgur.com/Y1SPbT0.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/Y1SPbT0.png"
        title="image-20240126172537764" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="10-virtual-machine">10. Virtual Machine</h1>
<ul>
<li>定義：利用Software技術，模擬出一份與底層硬體一模一樣的功能界面之抽象化機器 (abstract machine) 稱之</li>
</ul>
<p>【圖示】</p>
<ol>
<li>
<p><strong>Host</strong>: Underlying hardware system, Host OS, Host hardware</p>
</li>
<li>
<p><strong>VMM</strong> (Virtual Machine Manager) 或Hypervisor: Creates and manages/runs virtual machines專門負責建立、管理、執行VM的模組</p>
</li>
<li>
<p><strong>Guest</strong>: Process provided with virtual copy of the host Guest Applications, Guest OS</p>
</li>
</ol>
<p>![image-20240126172800689](/Users/wysiwyz/Library/Application Support/typora-user-images/image-20240126172800689.png)</p>
<blockquote>
<p>[恐] 之其它英文：</p>
<ul>
<li>
<p>Abstract hardware of a single computer into several different execution environments</p>
</li>
<li>
<p>Similar to layered approach, but layer creates virtual machine (VM)</p>
</li>
</ul>
<p>Hardware 主要有CPU, Memory, I/O-Devices</p>
<p>如何讓VM以為自己也有一顆CPU？Time-sharing</p>
<p>Memory？Virtual Memory</p>
<p>I/O-Devices？Spooling, buffering</p>
</blockquote>
<ul>
<li>
<p>優點/好處</p>
<ol>
<li>
<p>作為測試開發中的OS一個良好的負載平台，具有下列好處</p>
<ol>
<li>其它user, user processes工作仍可以持續運作，不須暫停</li>
<li>萬一測試中的OS不穩定、掛掉或是失敗了，也不會影響Host hardware OS其它user process之工作，因為只是相當於一個user process fails而已，會對系統有重大危害</li>
</ol>
</li>
<li>
<p>同一部Host Hardware可以執行多個OS，running on多個virtual machines可節省成本</p>
</li>
<li>
<p>Consolidation: 在cloud computing environment中，我們會用有限的機器（硬體），建立為數眾多的virtual machines，我們可以依VM上的applications之執行負擔輕重，調動Host Machines資源作因應的支援</p>
</li>
<li>
<p>VM較為安全：如果VM被病毒入侵，不至於擴散，因為VM之間是獨立的</p>
</li>
<li>
<p>可以Freeze, suspend, running VM 及clone (複製) VM</p>
</li>
</ol>
</li>
</ul>
<h4 id="vmm的implementation">VMM的implementation</h4>
<ol>
<li>
<p>Type 0 Hypervisor:</p>
<ul>
<li>
<p>Hardware-based solutions via firmware</p>
</li>
<li>
<p>e.g. IBM, LPARS and Oracle, LDOMS, etc</p>
</li>
</ul>
</li>
<li>
<p>Type 1 Hypervisor:</p>
<ul>
<li>
<p>OS-like software: e.g. VMWare ESX, Joyent SmartOS, Citrix XenServer</p>
</li>
<li>
<p>General purpose OS that provides VMM functions (services)</p>
<p>e.g. MicroSoft Window Server with HyperV, RedHat Linux with KVM</p>
</li>
</ul>
</li>
<li>
<p>Type 2 Hypervisor:</p>
<ul>
<li>
<p>Applications level provides VMM functionality</p>
</li>
<li>
<p>e.g. Parallel DeskTop (install Windows on Apple), Oracle VirtualBox</p>
</li>
</ul>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/WMKlkgB.png"
        data-srcset="https://i.imgur.com/WMKlkgB.png, https://i.imgur.com/WMKlkgB.png 1.5x, https://i.imgur.com/WMKlkgB.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/WMKlkgB.png"
        title="image-20240126173533373" /></p>
<h1 id="11-vmmhypervisor-implementation">11. VMM(Hypervisor) Implementation</h1>
<table>
<thead>
<tr>
<th></th>
<th>VMM</th>
<th>level of implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.</td>
<td>Type 0 Hypervisor</td>
<td>hardware level</td>
</tr>
<tr>
<td>2.</td>
<td>Type 1 Hypervisor</td>
<td>kernel mode</td>
</tr>
<tr>
<td>3.</td>
<td>Type 2 Hypervisor</td>
<td>user mode</td>
</tr>
</tbody>
</table>
<p>共同特徵：它們建立的VM並不等於底層的硬體</p>
<p>其它變形如下：</p>
<ol start="4">
<li>
<p>Paravirtualization:</p>
<ul>
<li>
<p>The guest OS need modify to work in cooperation with VMM to optimize performance</p>
</li>
<li>
<p>🐥It presents guest with similar but not identical to hardware(HW).</p>
<p>創造出來的硬體，呈現出來給guest與底層硬體並不完全一樣（只截取需要的部分）</p>
</li>
<li>
<p>🐥Guest must be modified to run on paravirtualization HW.</p>
<p>Guest OS如果要在Paravirtualization運行的話，一定要修改過</p>
</li>
</ul>
</li>
<li>
<p>Programming-environment Virtualization</p>
<ul>
<li>VMMs do not virtualize read HW, but instead create an optimized virtual system</li>
<li>e.g. Java Virtual Machine (JVM), Microsoft .NET</li>
</ul>
</li>
<li>
<p>Emulators 模擬器</p>
<ul>
<li>Allow application written from one hardware to run on a very different hardware, such as different type of CPU.</li>
</ul>
</li>
<li>
<p>Application Containment</p>
<ul>
<li>e.g. Oracle Solaris Zones, BSD Jails, IBM AIX WPARs</li>
<li>Solaris Zones早期是列在ParaVirtualization裡面</li>
<li>創造出來的是<strong>執行環境</strong>，而不是硬體</li>
</ul>
</li>
</ol>
<blockquote>
<p>JVM is a Specification, not an implementation.</p>
<p>JVM spec 規範了三點：</p>
<ol>
<li>Class Loader   下載到client端</li>
<li>Class Verifier   驗證是否安全</li>
<li>Java Interpreter 如何在不同硬體架構上開發Java</li>
</ol>
</blockquote>
<h4 id="policy與mechanism-政策策略-與-機制">Policy與Mechanism (政策/策略) 與 機制</h4>
<ul>
<li>
<p>Policy：</p>
<ol>
<li>定義 &ldquo;What&rdquo; to be provided</li>
<li>經常改變</li>
</ol>
</li>
<li>
<p>Mechanism：</p>
<ol>
<li>定義  &ldquo;How&rdquo; to do that</li>
<li>The underlying mechanism 甚少改變或不變</li>
</ol>
</li>
<li>
<p>設計原則：</p>
<p>&ldquo;Policy 與 Mechanism 宜 separate，以增進 system flexibility&rdquo;</p>
<p>政策與機制要隔離/獨立，這樣系統的維護/擴充/加強/管理會比較容易</p>
</li>
<li>
<p>舉例：硬體資源保護 &mdash; I/O、Memory、CPU</p>
<ol>
<li>
<p>運用Timer作為CPU protection ➡️ Mechanism   [附程式]</p>
<p>Maximum Time Quantum大小制定 ➡️ Policy   [參數]</p>
</li>
<li>
<p>CPU排班採優先權排班 Priority scheduling ➡️ Mechanism</p>
<p>Priority大小之定義 ➡️ Policy</p>
</li>
</ol>
</li>
</ul>
<h2 id="ch4-process-management-與-thread-management">Ch4: Process Management 與 Thread Management</h2>
<ol>
<li>Process定義、與Program比較</li>
<li>🌠 Process Control Block (PCB) 內容</li>
<li>🌠🌠🌠🌠🌠 Process State Transition Diagram (STD)</li>
<li>🌠🌠🌠 Scheduler種類：長期排班器、短期排班器、中期排班器</li>
<li>🌠🌠🌠 Context switching</li>
<li>🌠 Dispatcher, Dispatching latency 分派器與分派延遲</li>
<li>🌠🌠🌠🌠🌠 <strong>Process Control Operations</strong>（以 UNIX system call 為主的程式追蹤）</li>
<li>🌠🌠🌠 評估CPU scheduling performance之五個criteria</li>
<li>🌠🌠🌠🌠🌠 各種CPU排班法則介紹以及相關名詞（7個排班法則） (Starvation, Aging, preemptive, non-preemptive, Convoy effect)</li>
<li>特定系統排班設計 (✨✨multiprocessors system, ✨✨✨ real-time system)</li>
<li>Thread Management</li>
</ol>
<h1 id="12-process">12. Process</h1>
<ul>
<li>
<p>定義：A program in execution 執行中的程式 [恐龍本]</p>
<ul>
<li>Process建立之後，其主要組成有：
<ul>
<li>Process No. (ID)</li>
<li>Process State</li>
<li>Code section, data section
(這兩個合起來就是process memory space)</li>
<li>Programming Counter (PC, 程式計數器 - 內放下一條指令的位址）</li>
<li>Stack (保存參數、區域變數、返回位址,etc.)</li>
<li>CPU registers value, etc.</li>
</ul>
</li>
<li>是OS分配 Resource 之對象單位（Resource: CPU, I/O-Devices, Memory)</li>
</ul>
</li>
<li>
<p>與Program（程式）比較</p>
<table>
<thead>
<tr>
<th>Process</th>
<th>Program</th>
</tr>
</thead>
<tbody>
<tr>
<td>執行中的程式</td>
<td>Just a File stored in storage device</td>
</tr>
<tr>
<td>Active entity</td>
<td>Passive  entity</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="process-control-block-pcb-內容">Process Control Block (PCB) 內容</h4>
<ul>
<li>定義：OS為了管理所有Processes，會在 kernel memory 中，替每一個process各字，準備一個 Block（表格）記錄 process 之所有相關資訊</li>
</ul>
<h4 id="pcb主要內容有八個">PCB主要內容有（八個）</h4>
<ol>
<li>Process No.(ID): 處理程式編號是 <strong>unique</strong>（唯一的）</li>
<li>Process state: e.g. ready, running, wait, etc.</li>
<li>Programming Counter: 內放the <strong>next</strong> instruction’s address</li>
<li>CPU registers: e.g. 計錄使用到暫存器的值</li>
</ol>
<p>​              e.g. Accumulator, PSW (process status word), Stack Top, etc.</p>
<ol start="5">
<li>
<p>CPU scheduling info:</p>
<p>e.g. process優先權值 process arrival time (FIFO), etc.</p>
</li>
<li>
<p>Memory Management info</p>
<p>(隨OS Memory記憶體管理方法不同，紀錄不同資訊）</p>
<p>e.g. Base/limit register, 或 Page Table 或 segment table</p>
</li>
<li>
<p>Accounting Info</p>
<p>例: process已用多少cpu time，哪些資源，還剩多少資源、cpu time可用, etc.</p>
<blockquote>
<p>Note:</p>
<p>目的 (1) 記帳、收錢 (2) Administrator 調校效能的依據</p>
</blockquote>
</li>
<li>
<p>I/O Status info</p>
<p>例: process已發出多少I/O-request, 完成狀況如何, 佔用哪些I/O resources (目前) etc.</p>
</li>
</ol>
<h4 id="quests-1">Quests</h4>
<ul>
<li>
<p>下列哪一項並未隸屬於PCB？</p>
<ol>
<li>
<p>Process number</p>
</li>
<li>
<p>CPU register</p>
</li>
<li>
<p>I/O-Device Queue</p>
<p>➡️這是OS或device driver在管的。容易與I/O-Status Info混淆。</p>
</li>
<li>
<p>CPU scheduling info</p>
</li>
<li>
<p>Memory Management info</p>
</li>
</ol>
</li>
<li>
<p>Which of the following is not encoded in the process control block?</p>
<ol>
<li>
<p>process state</p>
</li>
<li>
<p>the bitmap of this process</p>
<p>➡️Bitmap是磁碟在用的（Disk可用空間管理方法之一)</p>
</li>
<li>
<p>cpu register</p>
</li>
<li>
<p>memory management</p>
</li>
</ol>
</li>
</ul>
<h4 id="process的state-transition-diagram">Process的State Transition Diagram</h4>
<ul>
<li>
<p>STD, 狀態轉換圖</p>
</li>
<li>
<p>目的：描述process之lifecycle</p>
</li>
<li>
<p>版本有三種</p>
<ol>
<li>恐龍本       5個 status 之STD ➡️ 看不到medium中程</li>
<li>Stalling版 7個 status STD</li>
<li>UNIX STD (Stalling版）</li>
</ol>
</li>
</ul>
<h5 id="恐龍本五個-status-之-std">恐龍本：五個 Status 之 STD</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://i.imgur.com/bqxOpsF.png"
        data-srcset="https://i.imgur.com/bqxOpsF.png, https://i.imgur.com/bqxOpsF.png 1.5x, https://i.imgur.com/bqxOpsF.png 2x"
        data-sizes="auto"
        alt="https://i.imgur.com/bqxOpsF.png"
        title="image-20240126181011915" /></p>
<table>
<thead>
<tr>
<th>State</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>New (create)</td>
<td>Process被建立，已分得PCB空間，尚未載入memory（或尚未取得memory資源）(有身分證但不知道住哪)</td>
</tr>
<tr>
<td>Ready</td>
<td>Process已在memory中，且在ready queue內，具有資格爭奪CPU</td>
</tr>
<tr>
<td>Running</td>
<td>Process取得CPU，執行中</td>
</tr>
<tr>
<td>Wait (blocked)</td>
<td>Process在waiting queue中，waiting for I/O completed or event occurs. 不會與其它 process 爭奪/競爭cpu</td>
</tr>
<tr>
<td>Exit (terminate/ zombie/ abort)</td>
<td>Process完成工作 正常結束 或 異常終止，此時可能其PCB空間尚未回收，因為要等其父親 (Parent Process) collect收集完該子Process之成果後，才會回收PCB這個表格的空間。其它資源(memory, cpu, I/O-Devices)已回收</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Transition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1️⃣</td>
<td>也叫Admit, 當Memory space足夠時, 可以由long-term scheduler (in batch sys.) 決定將此Job載入到memory中</td>
</tr>
<tr>
<td>2️⃣</td>
<td>叫 dispatch，由 short-term scheduler (cpu scheduler) 決定讓高優先權 process 取得 cpu</td>
</tr>
<tr>
<td>3️⃣</td>
<td>叫time-out/interrupted, etc. 執行中的Process因某些事件發生而被迫放棄cpu，回去ready Queue. e.g. time-out, interrupt發生, 高優先process到達, 排到隊伍你位置的前面</td>
</tr>
<tr>
<td>4️⃣</td>
<td>叫 wait for I/O-Completed or event occurs</td>
</tr>
<tr>
<td>5️⃣</td>
<td>I/O-Completed 或 Event occurs</td>
</tr>
<tr>
<td>6️⃣</td>
<td>Process完工或異常處理</td>
</tr>
</tbody>
</table>
<h4 id="stalling">Stalling</h4>
<ul>
<li>
<p>Medium term scheduling</p>
</li>
<li>
<p>Which of the five status has the property that its process is in memory?</p>
<p>〔New〕  〔<strong>Ready</strong>〕  〔<strong>Running</strong>〕  〔<strong>Wait</strong>〕  〔Exit〕</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Transition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Blocked/suspend</td>
<td>Process 被 swap out 到 Disk 中暫存，即 blocked (asleep) in Disk</td>
</tr>
<tr>
<td>Ready/suspend</td>
<td>event occurs or I/O-Completed.</td>
</tr>
<tr>
<td></td>
<td>ready in Disk</td>
</tr>
<tr>
<td>Suspend/ (swap out).  1️⃣</td>
<td>當記憶體memory空間不足，又有其它高優先權process須更多記憶體空間時，會由中期排班器 medium-term scheduler 決定將 blocked process</td>
</tr>
<tr>
<td>Activate/ swap in</td>
<td>swap-out到 Disk，以空出記憶體空間 memory space (記憶體-&gt;磁碟) 當memory space有空，medium-term scheduler可以將它們 swap in 回memory中，ready for execution</td>
</tr>
<tr>
<td>Suspend/ (swap out). 2️⃣</td>
<td>支持transition之理由有兩個: <!-- raw HTML omitted -->1️⃣ 所有blocked processes皆swap out後, 記憶體空間仍不足時</td>
</tr>
</tbody>
</table>
<iframe class="LikeCoin" height="235" src="https://button.like.co/in/embed/wysiwyz/button?referrer=http%3a%2f%2fwysiwyz.github.io%2fposts%2foperating_system%2f" width="100%" frameborder=0></iframe><div class="disqus markdown">
                
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'blog-wysiwyz';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            </div>
        </div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 1993-01-26</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://wysiwyz.github.io/posts/operating_system/" data-hashtag="OperatingSystem"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://wysiwyz.github.io/posts/operating_system/" data-title="Operating_system"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/operatingsystem/">OperatingSystem</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/direct-style/" class="prev" rel="prev" title=""><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i></a>
            <a href="/posts/algorithm/" class="next" rel="next" title="Algorithm">Algorithm<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">strict with yourself; lenient with others.</div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-CCS3QPVY5N', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-CCS3QPVY5N" async></script></body>
</html>
